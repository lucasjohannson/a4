// =============================================================================
//                        !!! DO NOT EDIT THIS FILE !!!
// =============================================================================

#include "common.h"
#include "deadlock_detector.h"
#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <memory>
#include <numeric>
#include <vector>

using VS = std::vector<std::string>;

static bool vscmp(VS v1, VS v2)
{
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
    return v1 == v2;
}

static VS splitc(const std::string& s, char split_char = '\n')
{
    VS res;
    std::stringstream iss(s);

    while (iss.good()) {
        std::string line;
        getline(iss, line, split_char);
        res.push_back(line);
    }
    // std::cout << "['" << join(res, "','") << "']\n";
    return res;
};

static void test(const std::string& test_name, const VS& lines, int lineno, const VS& cycle)
{
    std::cout << "- running " << std::setw(20) << std::left << test_name << " ..." << std::flush;

    int ret_line_no = 123;
    Timer timer;
    std::vector<std::string> ret_cycle;
    detect_deadlock(lines, ret_line_no, ret_cycle);
    std::cout << "  - finished in " << std::fixed << std::setprecision(4) << timer.elapsed() << "s";
    if (ret_line_no == lineno && vscmp(cycle, ret_cycle)) {
        std::cout << " PASSED\n";
        return;
    }
    // auto mw = std::accumulate(lines.begin(), lines.end(), 8, [](int & m, const  std::string
    // &line) -> int {
    //     return std::max(m, int(line.size()));
    // });

    int mw = 8;
    for (const auto& line : lines)
        mw = std::max(mw, int(line.size()));
    std::cout << " FAILED.\n"
              << "  - input:\n";
    std::cout << "    +" + std::string(mw + 2, '-') + "+\n";
    for (const auto& line : lines)
        std::cout << "    | " + line + std::string(mw - line.size(), ' ') + " |\n";

    std::cout << "    +" + std::string(mw + 2, '-') + "+\n";
    std::cout << "  - expected line_no  : " << std::setw(5) << std::left << lineno
              << " cycle: " << join(cycle, ",") << "\n"
              << "  - calculated line_no: " << std::setw(5) << std::left << ret_line_no
              << " cycle: " << join(ret_cycle, ",") << "\n";
}

static int run_tests()
{
    std::cout << "Running built-in mini-tests\n";
    std::stringstream iss;
    test("empty test", {}, -1, {});
    test("one edge test", { "1 -> 1" }, -1, {});
    test("tiny deadlock", splitc("p1 -> m1|p1 <- m2|p2 -> m2|p2 <- m1", '|'), 3, { "p1", "p2" });
    test(
        "tiny deadlock2", splitc("p1 -> m1|p1 <- m2|p2 -> m2|p2 <- m1|a -> b", '|'), 3,
        { "p1", "p2" });
    test(
        "tiny deadlock2", splitc("p1 -> m1|p1 <- m2|p2 -> m2|a -> b|p2 <- m1", '|'), 4,
        { "p1", "p2" });
    test(
        "tiny deadlock3", splitc("x <- y|p1 -> m1|p1 <- m2|p2 -> m2|a -> b|p2 <- m1", '|'), 5,
        { "p1", "p2" });
    test(
        "tiny deadlock4", splitc("x -> m1|p1 -> m1|p1 <- m2|p2 -> m2|y -> m1|p2 <- m1", '|'), 5,
        splitc("p1,p2,x,y", ','));
    test(
        "test1.txt",
        splitc("  2    <-   fork1    \n"
               " plato  ->     fork1 \n"
               "plato   ->  2        \n"
               "socrates -> fork1    \n"
               "socrates <- 2        "),
        -1, {});

    return 0;
}
static int run_graph()
{
    std::cout << "Reading in lines from stdin...\n";
    VS all_lines;
    int line_no = 0;
    while (1) {
        // read in the next line and quit loop on EOF
        auto line = stdin_readline();
        if (line.size() == 0)
            break;
        line_no++;

        // get rid of trailing \n
        if (line.size() && line.back() == '\n')
            line.pop_back();

        // parse input line, skip empty lines
        auto toks = split(line);
        if (toks.size() == 0)
            continue;

        // validate line
        if (toks.size() != 3 || (toks[1] != "->" && toks[1] != "<-") || !is_alnum(toks[0])
            || !is_alnum(toks[2])) {
            std::cout << "Syntax error on line " << line_no << ": " << line << "\n";
            exit(-1);
        }

        all_lines.push_back(line);
    }

    std::cout << "Running detect_deadlock()...\n";
    VS cycle;
    Timer timer;
    detect_deadlock(all_lines, line_no, cycle);
    if (cycle.size() == 0)
        std::cout << "No deadlock.\n";
    else {
        std::cout << "Deadlock on line[" << line_no << "] = ";
        if (line_no >= int(all_lines.size()) || line_no < 0)
            std::cout << " <invalid line_no!>\n";
        else
            std::cout << "'" << all_lines[line_no] << "'\n";
        std::cout << "Deadlocked processes: " << join(cycle, ", ") << "\n";
    }
    std::cout << "Elapsed time: " << std::fixed << std::setprecision(4) << timer.elapsed() << "s\n";

    return 0;
}
static int usage(const std::string& pname)
{
    std::cout << "Usage:\n"
              << "    " << pname << " [test]\n"
              << "        - to run built-in tests\n"
              << "    " << pname << " < input\n"
              << "        - to process input from stdin\n";
    return -1;
}

static int cppmain(const VS& args)
{
    if (args.size() == 2 && args[1] == "test")
        return run_tests();
    else if (args.size() == 1)
        return run_graph();
    else
        return usage(args[0]);
}

int main(int argc, char** argv)
{
    try {
        return cppmain({ argv + 0, argv + argc });
    } catch (...) {
        std::cerr << "Unhandled exception occurred."
                  << "\n";
        return -1;
    }
}
